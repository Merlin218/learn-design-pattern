# 设计原则

## （一）单一职责原则

**单一职责原则（SRP）：一个对象或方法，只做一件事情。**

当两个职责耦合在一起的时候，一个职责发生变化可能会影响到其他职责的实现，造成意想不到的破坏，这种耦合性得到的是低内聚和脆弱的设计。

### 设计模式中的SRP

#### 代理模式

图片预加载例子中，把添加img标签的功能和预加载图片的职责分开放到两个对象中，这两个对象各自都只有一个被修改的动机。在它们各自发生改变的时候，也不会影响另外的对象。

#### 迭代器模式

对于迭代的对象可能是数组，可能是类数组，我们需要把遍历的过程抽离出来成each对象，以后还要增加新的迭代方式，我们只需要修改each方法即可。

#### 单例模式

我们把管理单例的职责和创建登录浮窗的职责分别封装在两个方法里，这两个方法可以独立变化而互不影响，当它们连接在一起的时候，就完成了创建唯一登录浮窗的功能。

#### 装饰者模式

装饰者模式可以为对象动态增加职责，从另一个角度来看，这也是分离职责的一种方式。

我们把数据上报的功能单独放在一个函数里，然后把这个函数动态装饰到业务函数上面。

### 何时应该分离

要明确的是，并不是所有的职责都应该一一分离。

一方面，如果随着需求的变化，**有两个职责总是同时变化，那就不必分离他们。** 比如在ajax请求的时候，创建xhr对象和发送xhr请求几乎总是在一起的，那么创建xhr对象的职责和发送xhr请求的职责就没有必要分开。

另一方面，职责的变化轴线仅当它们确定会发生变化时才具有意义，即使两个职责已经被耦合在一起，但它们**还没有发生改变的征兆，那么也许没有必要主动分离它们**，在代码需要重构的时候再进行分离也不迟。

### 违反SRP原则

在方便性与稳定性之间要有一些取舍。具体是选择方便性还是稳定性，并没有标准答案，而是要取决于具体的应用环境。

### 优缺点

SRP原则的优点是降低了单个类或者对象的复杂度，按照职责把对象分解成更小的粒度，这**有助于代码的复用，也有利于进行单元测试**。当一个职责需要变更的时候，不会影响到其他的职责。

但SRP原则也有一些缺点，最明显的是会增加编写代码的复杂度。当我们按照职责把对象分解成更小的粒度之后，实际上也增大了这些对象之间相互联系的难度。

## （二）开放-封闭原则

软件实体（类、模块、函数）等应该是**可以扩展的，但是不可修改。**

### 开放和封闭

开放-封闭原则的思想：当需要改变一个程序的功能或者给这个程序增加新功能的时候，可以使用增加代码的方式，但是不允许改动程序的源代码。

### 用对象的多态性消除条件分支

**过多的条件分支语句是造成程序违反开放-封闭原则的一个常见原因**。每当需要增加一个新的if语句时，都要被迫改动原函数。把if换成switch-case是没有用的，这是一种换汤不换药的做法。实际上，**每当我们看到一大片的if或者swtich-case语句时，第一时间就应该考虑，能否利用对象的多态性来重构它们**。

在动物叫声的例子中，**由于每种动物的叫声都不同，所以动物具体怎么叫是可变的**，于是我们把动物具体怎么叫的逻辑从makeSound函数中分离出来。

而动物都会叫这是不变的，makeSound函数里的实现逻辑只跟动物都会叫有关，这样一来，makeSound就成了一个稳定和封闭的函数。

###  其他方式

#### 放置挂钩

放置挂钩（hook）也是分离变化的一种方式。我们在程序有可能发生变化的地方放置一个挂钩，挂钩的返回结果决定了程序的下一步走向。这样一来，原本的代码执行路径上就出现了一个分叉路口，程序未来的执行方向被预埋下多种可能性。

#### 使用回调函数

在JavaScript中，函数可以作为参数传递给另外一个函数，这是高阶函数的意义之一。在这种情况下，我们通常会把这个函数称为回调函数。在JavaScript版本的设计模式中，策略模式和命令模式等都可以用回调函数轻松实现。

回调函数是一种特殊的挂钩。我们可以把一部分易于变化的逻辑封装在回调函数里，然后把回调函数当作参数传入一个稳定和封闭的函数中。当回调函数被执行的时候，程序就可以因为回调函数的内部逻辑不同，而产生不同的结果。

#### 设计模式中的开闭原则

#### 装饰者模式

#### 发布订阅模式

发布-订阅模式用来降低多个对象之间的依赖关系，它可以取代对象之间硬编码的通知机制，一个对象不用再显式地调用另外一个对象的某个接口。当有新的订阅者出现时，发布者的代码不需要进行任何修改；同样当发布者需要改变时，也不会影响到之前的订阅者。

#### 模板方法模式

模板方法模式是一种典型的通过封装变化来提高系统扩展性的设计模式。

在一个运用了模板方法模式的程序中，子类的方法种类和执行顺序都是不变的，所以我们把这部分逻辑抽出来放到父类的模板方法里面；

而子类的方法具体怎么实现则是可变的，于是把这部分变化的逻辑封装到子类中。通过增加新的子类，便能给系统增加新的功能，并不需要改动抽象父类以及其他的子类，这也是符合开放-封闭原则的。

#### 策略模式

策略模式和模板方法模式是一对竞争者。在大多数情况下，它们可以相互替换使用。**模板方法模式基于继承的思想，而策略模式则偏重于组合和委托。**

策略模式将各种算法都封装成单独的策略类，这些策略类可以被交换使用。策略和使用策略的客户代码可以分别独立进行修改而互不影响。我们增加一个新的策略类也非常方便，完全不用修改之前的代码。

#### 代理模式

拿预加载图片举例，我们现在已有一个给图片设置src的函数myImage，当我们想为它增加图片预加载功能时，一种做法是改动myImage函数内部的代码，更好的做法是提供一个代理函数proxyMyImage，代理函数负责图片预加载，在图片预加载完成之后，再将请求转交给原来的myImage函数，myImage在这个过程中不需要任何改动。

预加载图片的功能和给图片设置src的功能被隔离在两个函数里，它们可以单独改变而互不影响。myImage不知晓代理的存在，它可以继续专注于自己的职责——给图片设置src。

#### 职责链模式

当我们增加一个新类型的函数时，不需要改动原有的函数代码，只需要在链条中增加一个新的节点。

### 开闭原则的相对性

有一些代码是无论如何也不能完全封闭的，总会存在一些无法对其封闭的变化。作为程序员，我们可以做到的有下面两点。

❏ 挑选出最容易发生变化的地方，然后构造抽象来封闭这些变化。
❏ 在不可避免发生修改的时候，尽量修改那些相对容易修改的地方。

## （三）最少知识原则

最少知识原则（LKP）说的是一个软件实体应当尽可能少地与其他实体发生相互作用。这里的软件实体是一个广义的概念，不仅包括对象，还包括系统、类、模块、函数、变量等。

### 减少对象之间的联系

**单一职责原则**指导我们把对象划分成较小的粒度，这可以**提高对象的可复用性**。**但越来越多的对象之间可能会产生错综复杂的联系**，如果修改了其中一个对象，很可能会影响到跟它相互引用的其他对象。对象和对象耦合在一起，有可能会降低它们的可复用性。

最少知识原则要求我们在设计程序时，应当尽量减少对象之间的交互。如果两个对象之间不必彼此直接通信，那么这两个对象就不要发生直接的相互联系。常见的做法是**引入一个第三者对象，来承担这些对象之间的通信作用**。如果一些对象需要向另一些对象发起请求，可以**通过第三者对象来转发这些请求**。

### 设计模式中的LKP

#### 中介者模式

中介者模式很好地体现了最少知识原则。通过增加一个中介者对象，让所有的相关对象都通过中介者对象来通信，而不是互相引用。所以，当一个对象发生改变时，只需要通知中介者对象即可。

#### 外观模式

外观模式的作用是对客户屏蔽一组子系统的复杂性。

**外观模式对客户提供一个简单易用的高层接口，高层接口会把客户的请求转发给子系统来完成具体的功能实现。** 

但在一段使用了外观模式的程序中，**请求外观并不是强制的**。如果外观不能满足客户的个性化需求，那么客户**也可以选择越过外观来直接访问子系统**。

外观模式的关键是定义一个高层接口去封装一组“子系统”。

外观模式的作用主要有两点：
❏ 为一组子系统提供一个简单便利的访问入口。
❏ 隔离客户与复杂子系统之间的联系，客户不用去了解子系统的细节。

从第二点来，外观模式是符合最少知识原则的。

### 封装在最少知识原则中的体现

对象之间难免产生联系，当一个对象必须引用另外一个对象的时候，我们可以让对象只暴露必要的接口，让对象之间的联系限制在最小的范围之内。

把变量的可见性限制在一个尽可能小的范围内，这个变量对其他不相关模块的影响就越小，变量被改写和发生冲突的机会也越小。这也是广义的最少知识原则的一种体现。

虽然遵守最小知识原则减少了对象之间的依赖，但也有可能增加一些庞大到难以维护的第三者对象。跟单一职责原则一样，在实际开发中，是否选择让代码符合最少知识原则，要根据具体的环境来定。

## （四）里氏替换原则

当扩展一个类时， 记住你应该要能在不修改客户端代码的情况下将子类的对象作为父类对象进行传递。

- 子类方法的参数类型必须与其超类的参数类型相匹配或更加抽象。
	- 比如：原来传递的是猫，重写的方法传递的是卡菲猫，这将导致其他物种的猫不兼容
- 子类方法的返回值类型必须与超类方法的返回值类型或是其子类别相匹配。
	-  比如：原来返回的是猫，重写的方法传递的是动物，这将导致返回的类型超过了原来的范围。
- 子类中的方法不应抛出基础方法预期之外的异常类型。
	- 可能出现捕获的错误无法识别。
- 子类不应该加强其前置条件
	- 比如原来方法有一个int参数，重写的方法要求一个正整数，这将导致部分传入负整数的情况报错。
- 子类不能削弱其后置条件。
	- 比如原来要求关闭数据库，重写的方法保持数据库的连接，客户端并不清楚，所以可能对后置操作尝试影响。
- 超类的不变量必须保留。
	- 不变量：让对象有意义的条件。
	- 比如：猫的不变量 是有四条腿、 一条尾巴和能够喵喵叫等。
- 子类不能修改超类中私有成员变量的值。

## （五）接口隔离原则

客户端不应被强迫依赖于其不使用的方法。

继承只允许类拥有一个超类， 但是它并不限制类可同时实现的接口的数量。 因此， 你不需要将大量无关的类塞进单个接口。

**你可将其拆分为更精细的接口，如有需要可在单个类中实现所有接口， 某些类也可只实现其中的一个接口。**

![](https://cdn.jsdelivr.net/gh/Merlin218/image-storage/picGo/202208291500725.png)

更好的方法是将接口拆分为多个部分。 能够实现原始接口的类现在只需改为实现多个精细的接口即 可。 其他类则可仅实现对自己有意义的接口。

![](https://cdn.jsdelivr.net/gh/Merlin218/image-storage/picGo/202208291500609.png)

与其他原则一样， 你可能会过度使用这条原则。 **不要进一步划分已经非常具体的接口。 记住， 创建的接口越多， 代码就越复杂。 因此要保持平衡。**

## （六）依赖倒置原则

高层次的类不应该依赖于低层次的类。 两者都应该依赖于抽象接口。抽象接口不应依赖于具体实现。 具体实现应该依赖于抽象接口。

- **低层次的类实现基础操作**(例如磁盘操作、 传输网络数据和连接数据库等)。

• **高层次类包含复杂业务逻辑**以指导低层次类执行特定操作。

有时人们会先设计低层次的类， 然后才会开发高层次的类。 当你在新系统上开发原型产品时， 这种情况很常见。 由于低 层次的东西还没有实现或不确定， 你甚至无法确定高层次类 能实现哪些功能。 如果采用这种方式，业务逻辑类可能会更 依赖于低层原语类。

依赖倒置原则建议改变这种依赖方式。

![](https://cdn.jsdelivr.net/gh/Merlin218/image-storage/picGo/202208300014154.png)

![](https://cdn.jsdelivr.net/gh/Merlin218/image-storage/picGo/202208300014258.png)
